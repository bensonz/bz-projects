/*
 * Peg solitaire solver
 *
 * 15-122 Principles of Imperative Computation */

#use <args>
#use <conio>
#use <util>

//move = [end row,end col,start row, start col]
typedef int[] move;

int row_start(move m)
//@requires \length(m)==4;
{
    return m[2];
}

int col_start(move m)
//@requires \length(m)==4;
{
    return m[3];
}

int row_end(move m)
//@requires \length(m)==4;
{
    return m[0];
}

int col_end(move m)
//@requires \length(m)==4;
{
    return m[1];
}

move create_move(int init, int final)
//@ensures \length(\result) == 4;
{
    move M = alloc_array(int,4);
    M[2] = init/8;
    M[3] = init%8;
    M[0] = final/8;
    M[1] = final%8;
    return M;
}

//from peg-main.c0
board move_on_board(board B,move M){
  int row1 = row_start(M);
  int row2 = row_end(M);
  int col1 = col_start(M);
  int col2 = col_end(M);
  int i = 8*row1+col1;
  int k = 8*row2+col2;
  int j = (i+k)/2;
  B[i] = 1-B[i];
  B[j] = 1-B[j];
  B[k] = 1-B[k];
  return B;
}

board move_off_board(board B,move M){
  int row1 = row_end(M);
  int row2 = row_start(M);
  int col1 = col_end(M);
  int col2 = col_start(M);
  int i = 8*row1+col1;
  int k = 8*row2+col2;
  int j = (i+k)/2;
  B[i] = 1-B[i];
  B[j] = 1-B[j];
  B[k] = 1-B[k];
  return B;
}

stack possible_moves(board B)
//@requires is_board(B);
//@ensures is_board(B);
{
    stack new = stack_new();
    for (int row = 0; row < 8; row++) {
        for (int col = 0; col < 8; col++) {
            int l = row * 8 + col;
            if (row>=2 && B[l] == 1 && B[l-8]==1 && B[l-16] == 0) {
                push(new,create_move(l,l-16));
            }
            if (row<=5 && B[l] == 1 && B[l+8]==1 && B[l+16] == 0) {
                push(new,create_move(l,l+16));
            }
            if (col<=5 && B[l] == 1 && B[l+1]==1 && B[l+2] == 0) {
                push(new,create_move(l,l+2));
            }
            if (col>=2 && B[l] == 1 && B[l-1]==1 && B[l-2] == 0) {
                push(new,create_move(l,l-2));
            }
        }
    }
    return new;
}

int min(int a, int b){
    if (a<b){return a;}
    else return b;
}

void print_stack(stack S){
  stack copy = stack_new();
  while (!stack_empty(S)){
    stackelem m = pop(S);
    push(copy,m);
  }
  while (!stack_empty(copy)){
    stackelem n = pop(copy);
    print("init");
    printint(n[2]);printint(n[3]);
    print("end");
    printint(n[0]);printint(n[1]);
    print("\n");
    push(S,n);
  }
}


int solve_num1(board B, stack S, int pegN)
//@requires is_board(B);
//@requires pegN >0;
{
    //because we dont have a base case, just find the min
    stack M = possible_moves(B);
    if (stack_empty(M)) return pegN;//
    int count = pegN;
    while (!stack_empty(M)) {
      move m = pop(M);
      B = move_on_board(B,m);
      push(S, m);
      int tmppegs = solve_num1(B, S, num_pegs(B));
      count = min(count, tmppegs);
      pop(S);
      B = move_off_board(B,m);
    }
    return count;
}

bool solve(board B, stack S, int pegN)
//@requires is_board(B);
//@requires pegN >0;
{
    stack pms = possible_moves(B);
    pegN = num_pegs(B);
    //base case, if peg number is 1, return true
    if (pegN == 1){return true;}
    else{
        //recursivly call on every possilbe move
        while (!stack_empty(pms)) {
            move m = pop(pms);
            B = move_on_board(B,m);
            push(S,m);
            if (solve(B,S,pegN)){
                return true;
            }
            else{
                pop(S);
                B = move_off_board(B,m);
            }
        }
    }
    return pegN == 1;
}

stack stack_copy(stack s){
    stack new = stack_new();
    stack copy = stack_new();
    while (!stack_empty(s)) {
        push(new,pop(s));
    }
    while (!stack_empty(new)) {
        stackelem m = pop(new);
        push(s,m);
        push(copy,m);
    }
    return copy;
}

void reverse_stack(stack S){
    stack new = stack_new();
    stack copy = stack_new();
    while(!stack_empty(S)){
        push(new,pop(S));
    }
    while(!stack_empty(new)){
        push(copy,pop(new));
    }
    while(!stack_empty(copy)){
        push(S,pop(copy));
    }
}

int peg_solve(board B, stack S)
//@requires is_board(B);
//@requires stack_empty(S);
//@ensures \result >= 1;
{
    int pegN = num_pegs(B);
    bool success = solve(B,S,pegN);
    reverse_stack(S);
    if (success){return 1;}
    else{
        stack M = stack_new();
        return solve_num1(B,M,pegN);
    }
}


