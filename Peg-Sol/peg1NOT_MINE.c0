/* * Peg solitaire solver * * 15-122 Principles of Imperative Computation */#use <args>#use <conio>#use <util>typedef stackelem move;int row_start(move m) {  return m->row_start;}int col_start(move m) {  return m->col_start;}int row_end(move m) {  return m->row_end;}int col_end(move m) {  return m->col_end;}stackelem create_move(int start, int end) {  /* Start, end indices are translated to     rows, columns based on an 8*8 board */  stackelem a = alloc(struct stack_node);  a->row_start = start/8;  a->col_start = start%8;  a->row_end = end/8;  a->col_end = end%8;  return a;}stack find_moves(board B) {  stack A = stack_new();  for (int row = 0; row < 8; row++)    {      for (int col = 0; col < 8; col++)        {          int k = row * 8 + col;          //Horizontal shifts can't be done at cols 1, 6.          if ((col < 6) && (B[k] == 1) && (B[k + 1] == 1) && (B[k + 2] == 0))            push(A, create_move(k, k + 2));          if ((col >= 2) && (B[k] == 1) && (B[k - 1] == 1) && (B[k - 2] == 0))            push(A, create_move(k, k - 2));          //Vertical shifts can't be done at rows 1, 6.          if ((row < 6) && (B[k] == 1) && (B[k + 8] == 1) && (B[k + 16] == 0))            push(A, create_move(k, k + 16));          if ((row >= 2) && (B[k] == 1) && (B[k - 8] == 1) && (B[k - 16] == 0))            push(A, create_move(k, k - 16));        }    }  return A;}int min(int a, int b){  if (a < b) return a;  else return b;}void move_board(board B, int row1, int col1, int row2, int col2){  //From peg-main.c0                                                                           int i = 8*row1+col1;  int k = 8*row2+col2;  int j = (i+k)/2;  B[i] = 1-B[i];  B[j] = 1-B[j];  B[k] = 1-B[j];  return;}int peg_help(board B, stack S, int pegs){  // Two base cases, victory and loss.  if (pegs == 1) {    return 1;  }  else {    stack M = find_moves(B);    if (stack_empty(M)) return pegs;    else {      stackelem m = pop(M);      move_board(B, m->row_start, m->col_start,                m->row_end, m->col_end);      push(S, m);      return min(pegs, peg_help(B, S, num_pegs(B)));     }  }}void reverse_stack(stack S){  stack A = stack_new();  stack B = stack_new();  while (!stack_empty(S)) { push(A, pop(S)); }  while (!stack_empty(A)) { push(B, pop(A)); }  while (!stack_empty(B)) { push(S, pop(B)); }}int peg_solve(board B, stack S)//@requires is_board(B);//@requires stack_empty(S);//@ensures is_board(B);//@ensures \result >= 1;{  int pegs = peg_help(B, S, num_pegs(B));  reverse_stack(S);  return pegs;}