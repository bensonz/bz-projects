/*
 * String Buffer Library
 *
 * 15-122 Principles of Imperative Computation
 * This version exposes the externals, requires
 * discipline from client! */

/*** Interface ***/
#use <conio>
struct strbuf {
  int limit;
  int len;
  char[] buf;
};
bool is_strbuf(struct strbuf* sb);

struct strbuf* strbuf_new(int init_limit);
char[] strbuf_str(struct strbuf* sb);
void strbuf_add(struct strbuf* sb, char[] str, int len);
void strbuf_addstr(struct strbuf* sb, char[] str);


/*** Implementation ***/
bool is_strbuf(struct strbuf* sb)
{
  println("checking");
  // if sb points to null, not valid
  if (sb == NULL){return false;}
  if (sb->len < 0 || sb->limit < 1){return false;}
  println("pass len> 0 & limit > 1");
  if (sb->len > sb->limit){return false;}
  println("pass len < limit");
  if (sb->buf [ sb->len ] != '\0'){return false;}
  println("pass buf len = nul");
  // go inside the buf and check
  print("sb->len = ");
  printint(sb->len);
  println(" ");
  for (int i = 0; i < sb->len; i++){
    if (sb->buf [ i ] == '\0'){
      if (i != sb->len-1) {printint(i);println("  oh shit");return false;}
    }
  }
  //still have to check length(sb->buf) == sb->limit
  //@assert \length(sb->buf) == sb->limit;
  println("pass no nul in the middle");
  println("pass all");
  return true;
}

struct strbuf* strbuf_new(int initial_limit)
//@ensures is_strbuf(\result);
{
  struct strbuf* sb = alloc(struct strbuf);
  sb->buf = alloc_array(char,initial_limit);
  sb->buf[0] = '\0';
  sb->len = 0;
  sb->limit = initial_limit;
  return sb;
}

char[] strbuf_str(struct strbuf* sb)
//@requires is_strbuf(sb);
//@ensures is_strbuf(sb);
//@ensures \length(\result) == sb->len+1;
//@ensures \result[sb->len] == '\0';
{
  char[] new = alloc_array(char,sb->len+1);
  for (int i = 0; i < sb->len+1; i++){
    new[i] = sb->buf[i];
  }
  return new;
}

void strbuf_add(struct strbuf* sb, char[] str, int str_len)
//@requires is_strbuf(sb);
//@requires \length(str) == str_len;
//@ensures is_strbuf(sb);
{
  //total length is the string length without nul
  int t_len = sb->len + str_len-1;
  //with the new string, if we need more space, make space
  //sb->limite -1 because the last one must be nul, so one space is taken
  if (t_len > sb->limit-1){
     sb->limit += str_len;
     char[] new_buf = alloc_array(char,t_len);
     //then move all the char in sb->buf and str into new_buf
     for (int i = 0;i < sb->len;i++){
         new_buf[i] = sb->buf[i];
     }
     //assign the pointer to our new buf
     sb->buf = new_buf;
  }
  //if the str can be added, just add it
  for (int i = sb->len; i < t_len; i++){
    sb->buf[i] = str[i-sb->len];
  }
  sb->len = t_len;
}

int str_len(char[] str){
  int i = 0;
  while (str[i] != '\0'){
    i++;
  }
  return i;
}

void strbuf_addstr(struct strbuf* sb, char[] str)
//@requires is_strbuf(sb);
//@ensures is_strbuf(sb);
{
  int i = str_len(str);
  strbuf_add(sb,str,i+1);
}
